# Введение

Аудио движок подключается с помощью "фич" `audio`, `extended_audio` и `raw_audio`.

Он состоит из двух частей:
 - хранилище треков (здесь просто находятся треки, которые можно проигрывать)
 - плейлист (проигрываемые в данный момент треки)

Для упрощение системы и увеличения её возможностей используются только одноканальные треки.
Это значит, что придётся разделять многоканальные треки на отдельные каналы, загружать,
проигрывать и редактировать отдельно каждый канал (но об этом позже).

Для аудио движка выделяется отдельный поток,
который при завершении работы закрывается с паникой (по-другому закрыть я его не смог),
так что не паникуйте.

Поддерживает только вывод.
Пока что позволяет декодировать только треки формата `mp3`.
Все треки переводятся в 24-битный формат для упрощения работы с ними.

Есть три варианта управления аудио движком:
 - через обёртку `AudioWrapper`, которая сильно упрощает работу, но уменьшает возможности
 - через функции самого движка
 - через прямые команды, без не нужных проверок индексов и переполнения


# Работа с `AudioWrapper`

Простой интерфейс, подойдёт для обычного проигрывания треков.

```
let settings=AudioSettings::new();
let audio=Audio::default(settings).unwrap();

let mut wrapper=AudioWrapper::new(audio);

wrapper.load_track("resources/audio.mp3","audio".to_string());

wrapper.play_track("audio",1u32).unwrap(); // Проигрывает трек один раз

wrapper.set_track_volume("audio",0.5f32).unwrap();
```

Дополнительные возможности:
 - доступ к более низкому уровню (см. `Работа с функциями движка`)
```
// Ставим на паузу трек в плейлисте
wrapper.audio.pause_track(0).unwrap();
```
- добавление, просмотр и изменение сетов
```
let sets=vec![
    Set{
        index:0, // индекс трека в хранилище
        channels:vec![0usize,1] // каналы, на которых будет проигрываться трек
    }
];
wrapper.push_sets("new".to_string(),sets);
let new_sets=wrapper.get_track_sets("new").unwrap();
```


# Работа с функциями движка

Позволяет выборочно управлять треками как через плейлист,
так и через хранилище.

Например, можно загрузить двуканальный трек и запустить только
один канал:
```
let settings=AudioSettings::new();
let audio=Audio::default(settings).unwrap();

// Загрузил через обёртку, потому что так удобнее
let mut wrapper=AudioWrapper::new(audio);
wrapper.load_track("resources/audio.mp3","audio3".to_string());

// Параметры проигрывания трека: сыграть один раз, на каналах 0 и 1
let set=TrackSet::once(0,vec![0,1]);
wrapper.audio.play_track(set).unwrap();

// Изменение громкости этого трека
wrapper.audio.set_track_volume(0,0.5f32).unwrap();
```


##### Доступ через плейлист и хранилище

Разница лишь в том, что плейлист позволяет управлять только тем треком,
на который указывает индекс.
В случае же с хранилищем доступны все треки в плейлисте,
которые относятся к выбранному треку в хранилище.
То есть, если вы запустили один и тот же трек несколько раз, то с помощью хранилища,
можно менять параметры проигрывания сразу всех, а с помощью плейлиста, каждый отдельно.
```
// Допустим индекс трека в хранилище - 0
let set=TrackSet::once(0,vec![0,1]);
// Индекс в плейлисте - 0
audio.play_track(set.clone()).unwrap();
// Индекс в плейлисте - 1
audio.play_track(set).unwrap();

// Останавливает треки в плейлисте с индексами 0 и 1
audio.stop_track_storage(0).unwrap();
// То же самое, что и выше
audio.stop_tracks(vec![0,1]).unwrap();
```


# Работа с прямыми командами

Особенность этого метода заключается в том, что вы полностью избавляетесь от внешних проверок. Однако даже в этом случае ядро движка обработает все ошибки и не даст системе вылететь, но никакого результата выполнения команд она не выдаёт.
Советую перед этим изучить внутреннее строение движка, чтобы правильно и эффективном им управлять.


### Расширенный режим

Подключается через `features=["extended_audio"]` и добаляет функции управления некоторыми
внутренними полями `Audio` и возможность прямой отправки команд ядру движка.


### Сырой режим

Подключается через `features=["raw_audio"]` и отключает все поля и функции `Audio`,
которые не имеют прямого отношения к работе ядра движка.